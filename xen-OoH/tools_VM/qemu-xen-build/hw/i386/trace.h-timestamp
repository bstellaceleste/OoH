/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_I386_GENERATED_TRACERS_H
#define TRACE_HW_I386_GENERATED_TRACERS_H

#include "qemu-common.h"
#include "trace/control.h"

extern TraceEvent _TRACE_X86_IOMMU_IEC_NOTIFY_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICE_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_DEVICES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_CC_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_PAGES_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IOTLB_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_SW_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_IRQ_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_DESC_IEC_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_SETUP_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_HEAD_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_INV_QI_FETCH_EVENT;
extern TraceEvent _TRACE_VTD_CONTEXT_CACHE_RESET_EVENT;
extern TraceEvent _TRACE_VTD_RE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_RE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_CE_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_VTD_CE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_PAGE_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_HIT_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_CC_UPDATE_EVENT;
extern TraceEvent _TRACE_VTD_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_VTD_FAULT_DISABLED_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_VALID_EVENT;
extern TraceEvent _TRACE_VTD_REPLAY_CE_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_LEVEL_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_ONE_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_READ_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_PERM_EVENT;
extern TraceEvent _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_EVENT;
extern TraceEvent _TRACE_VTD_SWITCH_ADDRESS_SPACE_EVENT;
extern TraceEvent _TRACE_VTD_AS_UNMAP_WHOLE_EVENT;
extern TraceEvent _TRACE_VTD_TRANSLATE_PT_EVENT;
extern TraceEvent _TRACE_VTD_PT_ENABLE_FAST_PATH_EVENT;
extern TraceEvent _TRACE_VTD_IRQ_GENERATE_EVENT;
extern TraceEvent _TRACE_VTD_REG_READ_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_EVENT;
extern TraceEvent _TRACE_VTD_REG_DMAR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_IR_ROOT_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_GCMD_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_FECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_WRITE_IECTL_EVENT;
extern TraceEvent _TRACE_VTD_REG_ICS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_DMAR_FAULT_EVENT;
extern TraceEvent _TRACE_VTD_IR_ENABLE_EVENT;
extern TraceEvent _TRACE_VTD_IR_IRTE_GET_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_TYPE_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_EVENT;
extern TraceEvent _TRACE_VTD_IR_REMAP_MSI_REQ_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_PPF_EVENT;
extern TraceEvent _TRACE_VTD_FSTS_CLEAR_IP_EVENT;
extern TraceEvent _TRACE_VTD_FRR_NEW_EVENT;
extern TraceEvent _TRACE_VTD_ERR_EVENT;
extern TraceEvent _TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW_EVENT;
extern TraceEvent _TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR_EVENT;
extern TraceEvent _TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR_EVENT;
extern TraceEvent _TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR_EVENT;
extern TraceEvent _TRACE_VTD_ERR_DMAR_TRANSLATE_EVENT;
extern TraceEvent _TRACE_VTD_WARN_INVALID_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_ERR_QI_DISABLE_EVENT;
extern TraceEvent _TRACE_VTD_ERR_QI_TAIL_EVENT;
extern TraceEvent _TRACE_VTD_ERR_IRTE_EVENT;
extern TraceEvent _TRACE_VTD_ERR_IRTE_SID_EVENT;
extern TraceEvent _TRACE_VTD_ERR_IRTE_SID_BUS_EVENT;
extern TraceEvent _TRACE_VTD_ERR_IRTE_SVT_EVENT;
extern TraceEvent _TRACE_VTD_ERR_IR_MSI_INVALID_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_VECTOR_EVENT;
extern TraceEvent _TRACE_VTD_WARN_IR_TRIGGER_EVENT;
extern TraceEvent _TRACE_AMDVI_EVNTLOG_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_CACHE_UPDATE_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_EVENT;
extern TraceEvent _TRACE_AMDVI_MMIO_READ_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_ERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_READ_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMMAND_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_AMDVI_INTR_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PREFETCH_PAGES_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGES_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_ALL_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_PPR_EXEC_EVENT;
extern TraceEvent _TRACE_AMDVI_DEVTAB_INVAL_EVENT;
extern TraceEvent _TRACE_AMDVI_COMPLETION_WAIT_EVENT;
extern TraceEvent _TRACE_AMDVI_CONTROL_STATUS_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_RESET_EVENT;
extern TraceEvent _TRACE_AMDVI_DTE_GET_FAIL_EVENT;
extern TraceEvent _TRACE_AMDVI_INVALID_DTE_EVENT;
extern TraceEvent _TRACE_AMDVI_GET_PTE_HWERROR_EVENT;
extern TraceEvent _TRACE_AMDVI_MODE_INVALID_EVENT;
extern TraceEvent _TRACE_AMDVI_PAGE_FAULT_EVENT;
extern TraceEvent _TRACE_AMDVI_IOTLB_HIT_EVENT;
extern TraceEvent _TRACE_AMDVI_TRANSLATION_RESULT_EVENT;
extern uint16_t _TRACE_X86_IOMMU_IEC_NOTIFY_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICE_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_DEVICES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_CC_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_GLOBAL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_DOMAIN_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_PAGES_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IOTLB_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_SW_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_IRQ_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_DESC_IEC_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_SETUP_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_HEAD_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_INV_QI_FETCH_DSTATE;
extern uint16_t _TRACE_VTD_CONTEXT_CACHE_RESET_DSTATE;
extern uint16_t _TRACE_VTD_RE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_RE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_CE_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_VTD_CE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_PAGE_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_HIT_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_CC_UPDATE_DSTATE;
extern uint16_t _TRACE_VTD_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_VTD_FAULT_DISABLED_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_VALID_DSTATE;
extern uint16_t _TRACE_VTD_REPLAY_CE_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_LEVEL_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_ONE_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_READ_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_PERM_DSTATE;
extern uint16_t _TRACE_VTD_PAGE_WALK_SKIP_RESERVE_DSTATE;
extern uint16_t _TRACE_VTD_SWITCH_ADDRESS_SPACE_DSTATE;
extern uint16_t _TRACE_VTD_AS_UNMAP_WHOLE_DSTATE;
extern uint16_t _TRACE_VTD_TRANSLATE_PT_DSTATE;
extern uint16_t _TRACE_VTD_PT_ENABLE_FAST_PATH_DSTATE;
extern uint16_t _TRACE_VTD_IRQ_GENERATE_DSTATE;
extern uint16_t _TRACE_VTD_REG_READ_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_DSTATE;
extern uint16_t _TRACE_VTD_REG_DMAR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_IR_ROOT_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_GCMD_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_FECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_WRITE_IECTL_DSTATE;
extern uint16_t _TRACE_VTD_REG_ICS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_DMAR_FAULT_DSTATE;
extern uint16_t _TRACE_VTD_IR_ENABLE_DSTATE;
extern uint16_t _TRACE_VTD_IR_IRTE_GET_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_TYPE_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_DSTATE;
extern uint16_t _TRACE_VTD_IR_REMAP_MSI_REQ_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_PPF_DSTATE;
extern uint16_t _TRACE_VTD_FSTS_CLEAR_IP_DSTATE;
extern uint16_t _TRACE_VTD_FRR_NEW_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR_DSTATE;
extern uint16_t _TRACE_VTD_ERR_DMAR_TRANSLATE_DSTATE;
extern uint16_t _TRACE_VTD_WARN_INVALID_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_ERR_QI_DISABLE_DSTATE;
extern uint16_t _TRACE_VTD_ERR_QI_TAIL_DSTATE;
extern uint16_t _TRACE_VTD_ERR_IRTE_DSTATE;
extern uint16_t _TRACE_VTD_ERR_IRTE_SID_DSTATE;
extern uint16_t _TRACE_VTD_ERR_IRTE_SID_BUS_DSTATE;
extern uint16_t _TRACE_VTD_ERR_IRTE_SVT_DSTATE;
extern uint16_t _TRACE_VTD_ERR_IR_MSI_INVALID_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_VECTOR_DSTATE;
extern uint16_t _TRACE_VTD_WARN_IR_TRIGGER_DSTATE;
extern uint16_t _TRACE_AMDVI_EVNTLOG_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_CACHE_UPDATE_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_DSTATE;
extern uint16_t _TRACE_AMDVI_MMIO_READ_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_ERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_READ_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMMAND_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_AMDVI_INTR_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PREFETCH_PAGES_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGES_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_ALL_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_PPR_EXEC_DSTATE;
extern uint16_t _TRACE_AMDVI_DEVTAB_INVAL_DSTATE;
extern uint16_t _TRACE_AMDVI_COMPLETION_WAIT_DSTATE;
extern uint16_t _TRACE_AMDVI_CONTROL_STATUS_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_RESET_DSTATE;
extern uint16_t _TRACE_AMDVI_DTE_GET_FAIL_DSTATE;
extern uint16_t _TRACE_AMDVI_INVALID_DTE_DSTATE;
extern uint16_t _TRACE_AMDVI_GET_PTE_HWERROR_DSTATE;
extern uint16_t _TRACE_AMDVI_MODE_INVALID_DSTATE;
extern uint16_t _TRACE_AMDVI_PAGE_FAULT_DSTATE;
extern uint16_t _TRACE_AMDVI_IOTLB_HIT_DSTATE;
extern uint16_t _TRACE_AMDVI_TRANSLATION_RESULT_DSTATE;
#define TRACE_X86_IOMMU_IEC_NOTIFY_ENABLED 1
#define TRACE_VTD_INV_DESC_ENABLED 1
#define TRACE_VTD_INV_DESC_INVALID_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICE_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_DEVICES_ENABLED 1
#define TRACE_VTD_INV_DESC_CC_INVALID_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_PAGES_ENABLED 1
#define TRACE_VTD_INV_DESC_IOTLB_INVALID_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_SW_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_IRQ_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_INVALID_ENABLED 1
#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_ENABLED 1
#define TRACE_VTD_INV_DESC_IEC_ENABLED 1
#define TRACE_VTD_INV_QI_ENABLE_ENABLED 1
#define TRACE_VTD_INV_QI_SETUP_ENABLED 1
#define TRACE_VTD_INV_QI_HEAD_ENABLED 1
#define TRACE_VTD_INV_QI_TAIL_ENABLED 1
#define TRACE_VTD_INV_QI_FETCH_ENABLED 1
#define TRACE_VTD_CONTEXT_CACHE_RESET_ENABLED 1
#define TRACE_VTD_RE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_RE_INVALID_ENABLED 1
#define TRACE_VTD_CE_NOT_PRESENT_ENABLED 1
#define TRACE_VTD_CE_INVALID_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_PAGE_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_CC_HIT_ENABLED 1
#define TRACE_VTD_IOTLB_CC_UPDATE_ENABLED 1
#define TRACE_VTD_IOTLB_RESET_ENABLED 1
#define TRACE_VTD_FAULT_DISABLED_ENABLED 1
#define TRACE_VTD_REPLAY_CE_VALID_ENABLED 1
#define TRACE_VTD_REPLAY_CE_INVALID_ENABLED 1
#define TRACE_VTD_PAGE_WALK_LEVEL_ENABLED 1
#define TRACE_VTD_PAGE_WALK_ONE_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_READ_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_PERM_ENABLED 1
#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_ENABLED 1
#define TRACE_VTD_SWITCH_ADDRESS_SPACE_ENABLED 1
#define TRACE_VTD_AS_UNMAP_WHOLE_ENABLED 1
#define TRACE_VTD_TRANSLATE_PT_ENABLED 1
#define TRACE_VTD_PT_ENABLE_FAST_PATH_ENABLED 1
#define TRACE_VTD_IRQ_GENERATE_ENABLED 1
#define TRACE_VTD_REG_READ_ENABLED 1
#define TRACE_VTD_REG_WRITE_ENABLED 1
#define TRACE_VTD_REG_DMAR_ROOT_ENABLED 1
#define TRACE_VTD_REG_IR_ROOT_ENABLED 1
#define TRACE_VTD_REG_WRITE_GCMD_ENABLED 1
#define TRACE_VTD_REG_WRITE_FECTL_ENABLED 1
#define TRACE_VTD_REG_WRITE_IECTL_ENABLED 1
#define TRACE_VTD_REG_ICS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_DMAR_TRANSLATE_ENABLED 1
#define TRACE_VTD_DMAR_ENABLE_ENABLED 1
#define TRACE_VTD_DMAR_FAULT_ENABLED 1
#define TRACE_VTD_IR_ENABLE_ENABLED 1
#define TRACE_VTD_IR_IRTE_GET_ENABLED 1
#define TRACE_VTD_IR_REMAP_ENABLED 1
#define TRACE_VTD_IR_REMAP_TYPE_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_ENABLED 1
#define TRACE_VTD_IR_REMAP_MSI_REQ_ENABLED 1
#define TRACE_VTD_FSTS_PPF_ENABLED 1
#define TRACE_VTD_FSTS_CLEAR_IP_ENABLED 1
#define TRACE_VTD_FRR_NEW_ENABLED 1
#define TRACE_VTD_ERR_ENABLED 1
#define TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW_ENABLED 1
#define TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR_ENABLED 1
#define TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR_ENABLED 1
#define TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR_ENABLED 1
#define TRACE_VTD_ERR_DMAR_TRANSLATE_ENABLED 1
#define TRACE_VTD_WARN_INVALID_QI_TAIL_ENABLED 1
#define TRACE_VTD_ERR_QI_DISABLE_ENABLED 1
#define TRACE_VTD_ERR_QI_TAIL_ENABLED 1
#define TRACE_VTD_ERR_IRTE_ENABLED 1
#define TRACE_VTD_ERR_IRTE_SID_ENABLED 1
#define TRACE_VTD_ERR_IRTE_SID_BUS_ENABLED 1
#define TRACE_VTD_ERR_IRTE_SVT_ENABLED 1
#define TRACE_VTD_ERR_IR_MSI_INVALID_ENABLED 1
#define TRACE_VTD_WARN_IR_VECTOR_ENABLED 1
#define TRACE_VTD_WARN_IR_TRIGGER_ENABLED 1
#define TRACE_AMDVI_EVNTLOG_FAIL_ENABLED 1
#define TRACE_AMDVI_CACHE_UPDATE_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_ENABLED 1
#define TRACE_AMDVI_MMIO_WRITE_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_ENABLED 1
#define TRACE_AMDVI_MMIO_READ_INVALID_ENABLED 1
#define TRACE_AMDVI_COMMAND_ERROR_ENABLED 1
#define TRACE_AMDVI_COMMAND_READ_FAIL_ENABLED 1
#define TRACE_AMDVI_COMMAND_EXEC_ENABLED 1
#define TRACE_AMDVI_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_AMDVI_INTR_INVAL_ENABLED 1
#define TRACE_AMDVI_IOTLB_INVAL_ENABLED 1
#define TRACE_AMDVI_PREFETCH_PAGES_ENABLED 1
#define TRACE_AMDVI_PAGES_INVAL_ENABLED 1
#define TRACE_AMDVI_ALL_INVAL_ENABLED 1
#define TRACE_AMDVI_PPR_EXEC_ENABLED 1
#define TRACE_AMDVI_DEVTAB_INVAL_ENABLED 1
#define TRACE_AMDVI_COMPLETION_WAIT_ENABLED 1
#define TRACE_AMDVI_CONTROL_STATUS_ENABLED 1
#define TRACE_AMDVI_IOTLB_RESET_ENABLED 1
#define TRACE_AMDVI_DTE_GET_FAIL_ENABLED 1
#define TRACE_AMDVI_INVALID_DTE_ENABLED 1
#define TRACE_AMDVI_GET_PTE_HWERROR_ENABLED 1
#define TRACE_AMDVI_MODE_INVALID_ENABLED 1
#define TRACE_AMDVI_PAGE_FAULT_ENABLED 1
#define TRACE_AMDVI_IOTLB_HIT_ENABLED 1
#define TRACE_AMDVI_TRANSLATION_RESULT_ENABLED 1
#include "qemu/log.h"


#define TRACE_X86_IOMMU_IEC_NOTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_X86_IOMMU_IEC_NOTIFY) || \
    false)

static inline void _nocheck__trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_X86_IOMMU_IEC_NOTIFY)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:x86_iommu_iec_notify " "Notify IEC invalidation: global=%d index=%" PRIu32 " mask=%" PRIu32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , global, index, mask);
    }
}

static inline void trace_x86_iommu_iec_notify(bool global, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_x86_iommu_iec_notify(global, index, mask);
    }
}

#define TRACE_VTD_INV_DESC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc " "invalidate desc type %s high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , type, hi, lo);
    }
}

static inline void trace_vtd_inv_desc(const char * type, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc(type, hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_invalid " "invalid inv desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_invalid(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_CC_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DOMAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_cc_domain " "context invalidate domain 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , domain);
    }
}

static inline void trace_vtd_inv_desc_cc_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_CC_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_GLOBAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_cc_global " "context invalidate globally" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_inv_desc_cc_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_global();
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICE) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_cc_device " "context invalidate device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, dev, fn);
    }
}

static inline void trace_vtd_inv_desc_cc_device(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_device(bus, dev, fn);
    }
}

#define TRACE_VTD_INV_DESC_CC_DEVICES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_DEVICES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_DEVICES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_cc_devices " "context invalidate devices sid 0x%"PRIx16" fmask 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, fmask);
    }
}

static inline void trace_vtd_inv_desc_cc_devices(uint16_t sid, uint16_t fmask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_devices(sid, fmask);
    }
}

#define TRACE_VTD_INV_DESC_CC_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_CC_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_cc_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_CC_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_cc_invalid " "invalid context-cache desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_cc_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_cc_invalid(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_GLOBAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_GLOBAL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_global(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_GLOBAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_iotlb_global " "iotlb invalidate global" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_inv_desc_iotlb_global(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_global();
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_DOMAIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_DOMAIN) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_DOMAIN)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_iotlb_domain " "iotlb invalidate whole domain 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , domain);
    }
}

static inline void trace_vtd_inv_desc_iotlb_domain(uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_domain(domain);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_PAGES) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_PAGES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_iotlb_pages " "iotlb invalidate domain 0x%"PRIx16" addr 0x%"PRIx64" mask 0x%"PRIx8 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , domain, addr, mask);
    }
}

static inline void trace_vtd_inv_desc_iotlb_pages(uint16_t domain, uint64_t addr, uint8_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_pages(domain, addr, mask);
    }
}

#define TRACE_VTD_INV_DESC_IOTLB_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IOTLB_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iotlb_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IOTLB_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_iotlb_invalid " "invalid iotlb desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_iotlb_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iotlb_invalid(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_SW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_SW) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_SW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_wait_sw " "wait invalidate status write addr 0x%"PRIx64" data 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, data);
    }
}

static inline void trace_vtd_inv_desc_wait_sw(uint64_t addr, uint32_t data)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_sw(addr, data);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_IRQ) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_IRQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_wait_irq " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , msg);
    }
}

static inline void trace_vtd_inv_desc_wait_irq(const char * msg)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_irq(msg);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_wait_invalid " "invalid wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_wait_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_invalid(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_WAIT_WRITE_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_wait_write_fail " "write fail for wait desc hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_inv_desc_wait_write_fail(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_wait_write_fail(hi, lo);
    }
}

#define TRACE_VTD_INV_DESC_IEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_DESC_IEC) || \
    false)

static inline void _nocheck__trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (trace_event_get_state(TRACE_VTD_INV_DESC_IEC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_desc_iec " "granularity 0x%"PRIx32" index 0x%"PRIx32" mask 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , granularity, index, mask);
    }
}

static inline void trace_vtd_inv_desc_iec(uint32_t granularity, uint32_t index, uint32_t mask)
{
    if (true) {
        _nocheck__trace_vtd_inv_desc_iec(granularity, index, mask);
    }
}

#define TRACE_VTD_INV_QI_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_enable(bool enable)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_qi_enable " "enabled %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , enable);
    }
}

static inline void trace_vtd_inv_qi_enable(bool enable)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_enable(enable);
    }
}

#define TRACE_VTD_INV_QI_SETUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_SETUP) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_SETUP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_qi_setup " "addr 0x%"PRIx64" size %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size);
    }
}

static inline void trace_vtd_inv_qi_setup(uint64_t addr, int size)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_setup(addr, size);
    }
}

#define TRACE_VTD_INV_QI_HEAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_HEAD) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_head(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_HEAD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_qi_head " "read head %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , head);
    }
}

static inline void trace_vtd_inv_qi_head(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_head(head);
    }
}

#define TRACE_VTD_INV_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_tail(uint16_t head)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_TAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_qi_tail " "write tail %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , head);
    }
}

static inline void trace_vtd_inv_qi_tail(uint16_t head)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_tail(head);
    }
}

#define TRACE_VTD_INV_QI_FETCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_INV_QI_FETCH) || \
    false)

static inline void _nocheck__trace_vtd_inv_qi_fetch(void)
{
    if (trace_event_get_state(TRACE_VTD_INV_QI_FETCH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_inv_qi_fetch " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_inv_qi_fetch(void)
{
    if (true) {
        _nocheck__trace_vtd_inv_qi_fetch();
    }
}

#define TRACE_VTD_CONTEXT_CACHE_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CONTEXT_CACHE_RESET) || \
    false)

static inline void _nocheck__trace_vtd_context_cache_reset(void)
{
    if (trace_event_get_state(TRACE_VTD_CONTEXT_CACHE_RESET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_context_cache_reset " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_context_cache_reset(void)
{
    if (true) {
        _nocheck__trace_vtd_context_cache_reset();
    }
}

#define TRACE_VTD_RE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_RE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_re_not_present(uint8_t bus)
{
    if (trace_event_get_state(TRACE_VTD_RE_NOT_PRESENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_re_not_present " "Root entry bus %"PRIu8" not present" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus);
    }
}

static inline void trace_vtd_re_not_present(uint8_t bus)
{
    if (true) {
        _nocheck__trace_vtd_re_not_present(bus);
    }
}

#define TRACE_VTD_RE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_RE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_re_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_RE_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_re_invalid " "invalid root entry hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_re_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_re_invalid(hi, lo);
    }
}

#define TRACE_VTD_CE_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CE_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (trace_event_get_state(TRACE_VTD_CE_NOT_PRESENT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ce_not_present " "Context entry bus %"PRIu8" devfn %"PRIu8" not present" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, devfn);
    }
}

static inline void trace_vtd_ce_not_present(uint8_t bus, uint8_t devfn)
{
    if (true) {
        _nocheck__trace_vtd_ce_not_present(bus, devfn);
    }
}

#define TRACE_VTD_CE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_CE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_ce_invalid(uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_CE_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ce_invalid " "invalid context entry hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , hi, lo);
    }
}

static inline void trace_vtd_ce_invalid(uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_ce_invalid(hi, lo);
    }
}

#define TRACE_VTD_IOTLB_PAGE_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_HIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_iotlb_page_hit " "IOTLB page hit sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, addr, slpte, domain);
    }
}

static inline void trace_vtd_iotlb_page_hit(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_hit(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_PAGE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_PAGE_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_PAGE_UPDATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_iotlb_page_update " "IOTLB page update sid 0x%"PRIx16" iova 0x%"PRIx64" slpte 0x%"PRIx64" domain 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, addr, slpte, domain);
    }
}

static inline void trace_vtd_iotlb_page_update(uint16_t sid, uint64_t addr, uint64_t slpte, uint16_t domain)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_page_update(sid, addr, slpte, domain);
    }
}

#define TRACE_VTD_IOTLB_CC_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_HIT) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_HIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_iotlb_cc_hit " "IOTLB context hit bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, devfn, high, low, gen);
    }
}

static inline void trace_vtd_iotlb_cc_hit(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_hit(bus, devfn, high, low, gen);
    }
}

#define TRACE_VTD_IOTLB_CC_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_CC_UPDATE) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_CC_UPDATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_iotlb_cc_update " "IOTLB context update bus 0x%"PRIx8" devfn 0x%"PRIx8" high 0x%"PRIx64" low 0x%"PRIx64" gen %"PRIu32" -> gen %"PRIu32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, devfn, high, low, gen1, gen2);
    }
}

static inline void trace_vtd_iotlb_cc_update(uint8_t bus, uint8_t devfn, uint64_t high, uint64_t low, uint32_t gen1, uint32_t gen2)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_cc_update(bus, devfn, high, low, gen1, gen2);
    }
}

#define TRACE_VTD_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_vtd_iotlb_reset(const char * reason)
{
    if (trace_event_get_state(TRACE_VTD_IOTLB_RESET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_iotlb_reset " "IOTLB reset (reason: %s)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reason);
    }
}

static inline void trace_vtd_iotlb_reset(const char * reason)
{
    if (true) {
        _nocheck__trace_vtd_iotlb_reset(reason);
    }
}

#define TRACE_VTD_FAULT_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FAULT_DISABLED) || \
    false)

static inline void _nocheck__trace_vtd_fault_disabled(void)
{
    if (trace_event_get_state(TRACE_VTD_FAULT_DISABLED)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_fault_disabled " "Fault processing disabled for context entry" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_fault_disabled(void)
{
    if (true) {
        _nocheck__trace_vtd_fault_disabled();
    }
}

#define TRACE_VTD_REPLAY_CE_VALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_VALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_valid(uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_VALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_replay_ce_valid " "replay valid context device %02"PRIx8":%02"PRIx8".%02"PRIx8" domain 0x%"PRIx16" hi 0x%"PRIx64" lo 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, dev, fn, domain, hi, lo);
    }
}

static inline void trace_vtd_replay_ce_valid(uint8_t bus, uint8_t dev, uint8_t fn, uint16_t domain, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_valid(bus, dev, fn, domain, hi, lo);
    }
}

#define TRACE_VTD_REPLAY_CE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REPLAY_CE_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (trace_event_get_state(TRACE_VTD_REPLAY_CE_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_replay_ce_invalid " "replay invalid context device %02"PRIx8":%02"PRIx8".%02"PRIx8 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, dev, fn);
    }
}

static inline void trace_vtd_replay_ce_invalid(uint8_t bus, uint8_t dev, uint8_t fn)
{
    if (true) {
        _nocheck__trace_vtd_replay_ce_invalid(bus, dev, fn);
    }
}

#define TRACE_VTD_PAGE_WALK_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_LEVEL) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_LEVEL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_page_walk_level " "walk (base=0x%"PRIx64", level=%"PRIu32") iova range 0x%"PRIx64" - 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, level, start, end);
    }
}

static inline void trace_vtd_page_walk_level(uint64_t addr, uint32_t level, uint64_t start, uint64_t end)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_level(addr, level, start, end);
    }
}

#define TRACE_VTD_PAGE_WALK_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_ONE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_one(uint32_t level, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_ONE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_page_walk_one " "detected page level 0x%"PRIx32" iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64" perm %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , level, iova, gpa, mask, perm);
    }
}

static inline void trace_vtd_page_walk_one(uint32_t level, uint64_t iova, uint64_t gpa, uint64_t mask, int perm)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_one(level, iova, gpa, mask, perm);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_READ) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_page_walk_skip_read " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to unable to read" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, next);
    }
}

static inline void trace_vtd_page_walk_skip_read(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_read(iova, next);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_PERM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_PERM) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_perm(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_PERM)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_page_walk_skip_perm " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to perm empty" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, next);
    }
}

static inline void trace_vtd_page_walk_skip_perm(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_perm(iova, next);
    }
}

#define TRACE_VTD_PAGE_WALK_SKIP_RESERVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PAGE_WALK_SKIP_RESERVE) || \
    false)

static inline void _nocheck__trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (trace_event_get_state(TRACE_VTD_PAGE_WALK_SKIP_RESERVE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_page_walk_skip_reserve " "Page walk skip iova 0x%"PRIx64" - 0x%"PRIx64" due to rsrv set" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, next);
    }
}

static inline void trace_vtd_page_walk_skip_reserve(uint64_t iova, uint64_t next)
{
    if (true) {
        _nocheck__trace_vtd_page_walk_skip_reserve(iova, next);
    }
}

#define TRACE_VTD_SWITCH_ADDRESS_SPACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_SWITCH_ADDRESS_SPACE) || \
    false)

static inline void _nocheck__trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (trace_event_get_state(TRACE_VTD_SWITCH_ADDRESS_SPACE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_switch_address_space " "Device %02x:%02x.%x switching address space (iommu enabled=%d)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, fn, on);
    }
}

static inline void trace_vtd_switch_address_space(uint8_t bus, uint8_t slot, uint8_t fn, bool on)
{
    if (true) {
        _nocheck__trace_vtd_switch_address_space(bus, slot, fn, on);
    }
}

#define TRACE_VTD_AS_UNMAP_WHOLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_AS_UNMAP_WHOLE) || \
    false)

static inline void _nocheck__trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_AS_UNMAP_WHOLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_as_unmap_whole " "Device %02x:%02x.%x start 0x%"PRIx64" size 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, fn, iova, size);
    }
}

static inline void trace_vtd_as_unmap_whole(uint8_t bus, uint8_t slot, uint8_t fn, uint64_t iova, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_as_unmap_whole(bus, slot, fn, iova, size);
    }
}

#define TRACE_VTD_TRANSLATE_PT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_TRANSLATE_PT) || \
    false)

static inline void _nocheck__trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (trace_event_get_state(TRACE_VTD_TRANSLATE_PT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_translate_pt " "source id 0x%"PRIu16", iova 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, addr);
    }
}

static inline void trace_vtd_translate_pt(uint16_t sid, uint64_t addr)
{
    if (true) {
        _nocheck__trace_vtd_translate_pt(sid, addr);
    }
}

#define TRACE_VTD_PT_ENABLE_FAST_PATH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_PT_ENABLE_FAST_PATH) || \
    false)

static inline void _nocheck__trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (trace_event_get_state(TRACE_VTD_PT_ENABLE_FAST_PATH)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_pt_enable_fast_path " "sid 0x%"PRIu16" %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, success);
    }
}

static inline void trace_vtd_pt_enable_fast_path(uint16_t sid, bool success)
{
    if (true) {
        _nocheck__trace_vtd_pt_enable_fast_path(sid, success);
    }
}

#define TRACE_VTD_IRQ_GENERATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IRQ_GENERATE) || \
    false)

static inline void _nocheck__trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IRQ_GENERATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_irq_generate " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, data);
    }
}

static inline void trace_vtd_irq_generate(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_irq_generate(addr, data);
    }
}

#define TRACE_VTD_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_READ) || \
    false)

static inline void _nocheck__trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_read " "addr 0x%"PRIx64" size 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size);
    }
}

static inline void trace_vtd_reg_read(uint64_t addr, uint64_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_read(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE) || \
    false)

static inline void _nocheck__trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_write " "addr 0x%"PRIx64" size 0x%"PRIx64" value 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size, val);
    }
}

static inline void trace_vtd_reg_write(uint64_t addr, uint64_t size, uint64_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write(addr, size, val);
    }
}

#define TRACE_VTD_REG_DMAR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_DMAR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_dmar_root(uint64_t addr, bool extended)
{
    if (trace_event_get_state(TRACE_VTD_REG_DMAR_ROOT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_dmar_root " "addr 0x%"PRIx64" extended %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, extended);
    }
}

static inline void trace_vtd_reg_dmar_root(uint64_t addr, bool extended)
{
    if (true) {
        _nocheck__trace_vtd_reg_dmar_root(addr, extended);
    }
}

#define TRACE_VTD_REG_IR_ROOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_IR_ROOT) || \
    false)

static inline void _nocheck__trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (trace_event_get_state(TRACE_VTD_REG_IR_ROOT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_ir_root " "addr 0x%"PRIx64" size 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, size);
    }
}

static inline void trace_vtd_reg_ir_root(uint64_t addr, uint32_t size)
{
    if (true) {
        _nocheck__trace_vtd_reg_ir_root(addr, size);
    }
}

#define TRACE_VTD_REG_WRITE_GCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_GCMD) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_GCMD)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_write_gcmd " "status 0x%"PRIx32" value 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , status, val);
    }
}

static inline void trace_vtd_reg_write_gcmd(uint32_t status, uint32_t val)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_gcmd(status, val);
    }
}

#define TRACE_VTD_REG_WRITE_FECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_FECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_fectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_FECTL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_write_fectl " "value 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_vtd_reg_write_fectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_fectl(value);
    }
}

#define TRACE_VTD_REG_WRITE_IECTL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_WRITE_IECTL) || \
    false)

static inline void _nocheck__trace_vtd_reg_write_iectl(uint32_t value)
{
    if (trace_event_get_state(TRACE_VTD_REG_WRITE_IECTL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_write_iectl " "value 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , value);
    }
}

static inline void trace_vtd_reg_write_iectl(uint32_t value)
{
    if (true) {
        _nocheck__trace_vtd_reg_write_iectl(value);
    }
}

#define TRACE_VTD_REG_ICS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_REG_ICS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_reg_ics_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_REG_ICS_CLEAR_IP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_reg_ics_clear_ip " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_reg_ics_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_reg_ics_clear_ip();
    }
}

#define TRACE_VTD_DMAR_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_TRANSLATE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_TRANSLATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64" -> gpa 0x%"PRIx64" mask 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, func, iova, gpa, mask);
    }
}

static inline void trace_vtd_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova, uint64_t gpa, uint64_t mask)
{
    if (true) {
        _nocheck__trace_vtd_dmar_translate(bus, slot, func, iova, gpa, mask);
    }
}

#define TRACE_VTD_DMAR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_dmar_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_dmar_enable " "enable %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , en);
    }
}

static inline void trace_vtd_dmar_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_dmar_enable(en);
    }
}

#define TRACE_VTD_DMAR_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_DMAR_FAULT) || \
    false)

static inline void _nocheck__trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (trace_event_get_state(TRACE_VTD_DMAR_FAULT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_dmar_fault " "sid 0x%"PRIx16" fault %d addr 0x%"PRIx64" write %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, fault, addr, is_write);
    }
}

static inline void trace_vtd_dmar_fault(uint16_t sid, int fault, uint64_t addr, bool is_write)
{
    if (true) {
        _nocheck__trace_vtd_dmar_fault(sid, fault, addr, is_write);
    }
}

#define TRACE_VTD_IR_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_ENABLE) || \
    false)

static inline void _nocheck__trace_vtd_ir_enable(bool en)
{
    if (trace_event_get_state(TRACE_VTD_IR_ENABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_enable " "enable %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , en);
    }
}

static inline void trace_vtd_ir_enable(bool en)
{
    if (true) {
        _nocheck__trace_vtd_ir_enable(en);
    }
}

#define TRACE_VTD_IR_IRTE_GET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_IRTE_GET) || \
    false)

static inline void _nocheck__trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (trace_event_get_state(TRACE_VTD_IR_IRTE_GET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_irte_get " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, lo, hi);
    }
}

static inline void trace_vtd_ir_irte_get(int index, uint64_t lo, uint64_t hi)
{
    if (true) {
        _nocheck__trace_vtd_ir_irte_get(index, lo, hi);
    }
}

#define TRACE_VTD_IR_REMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_remap " "index %d trigger %d vector %d deliver %d dest 0x%"PRIx32" mode %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, tri, vec, deliver, dest, dest_mode);
    }
}

static inline void trace_vtd_ir_remap(int index, int tri, int vec, int deliver, uint32_t dest, int dest_mode)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap(index, tri, vec, deliver, dest, dest_mode);
    }
}

#define TRACE_VTD_IR_REMAP_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_TYPE) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_type(const char * type)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_TYPE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_remap_type " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , type);
    }
}

static inline void trace_vtd_ir_remap_type(const char * type)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_type(type);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_remap_msi " "(addr 0x%"PRIx64", data 0x%"PRIx64") -> (addr 0x%"PRIx64", data 0x%"PRIx64")" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, data, addr2, data2);
    }
}

static inline void trace_vtd_ir_remap_msi(uint64_t addr, uint64_t data, uint64_t addr2, uint64_t data2)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi(addr, data, addr2, data2);
    }
}

#define TRACE_VTD_IR_REMAP_MSI_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_IR_REMAP_MSI_REQ) || \
    false)

static inline void _nocheck__trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_IR_REMAP_MSI_REQ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_ir_remap_msi_req " "addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, data);
    }
}

static inline void trace_vtd_ir_remap_msi_req(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_ir_remap_msi_req(addr, data);
    }
}

#define TRACE_VTD_FSTS_PPF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_PPF) || \
    false)

static inline void _nocheck__trace_vtd_fsts_ppf(bool set)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_PPF)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_fsts_ppf " "FSTS PPF bit set to %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , set);
    }
}

static inline void trace_vtd_fsts_ppf(bool set)
{
    if (true) {
        _nocheck__trace_vtd_fsts_ppf(set);
    }
}

#define TRACE_VTD_FSTS_CLEAR_IP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FSTS_CLEAR_IP) || \
    false)

static inline void _nocheck__trace_vtd_fsts_clear_ip(void)
{
    if (trace_event_get_state(TRACE_VTD_FSTS_CLEAR_IP)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_fsts_clear_ip " "" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_vtd_fsts_clear_ip(void)
{
    if (true) {
        _nocheck__trace_vtd_fsts_clear_ip();
    }
}

#define TRACE_VTD_FRR_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_FRR_NEW) || \
    false)

static inline void _nocheck__trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (trace_event_get_state(TRACE_VTD_FRR_NEW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_frr_new " "index %d high 0x%"PRIx64" low 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, hi, lo);
    }
}

static inline void trace_vtd_frr_new(int index, uint64_t hi, uint64_t lo)
{
    if (true) {
        _nocheck__trace_vtd_frr_new(index, hi, lo);
    }
}

#define TRACE_VTD_ERR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR) || \
    false)

static inline void _nocheck__trace_vtd_err(const char * str)
{
    if (trace_event_get_state(TRACE_VTD_ERR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err " "%s" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , str);
    }
}

static inline void trace_vtd_err(const char * str)
{
    if (true) {
        _nocheck__trace_vtd_err(str);
    }
}

#define TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW) || \
    false)

static inline void _nocheck__trace_vtd_err_dmar_iova_overflow(uint64_t iova)
{
    if (trace_event_get_state(TRACE_VTD_ERR_DMAR_IOVA_OVERFLOW)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_dmar_iova_overflow " "iova 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova);
    }
}

static inline void trace_vtd_err_dmar_iova_overflow(uint64_t iova)
{
    if (true) {
        _nocheck__trace_vtd_err_dmar_iova_overflow(iova);
    }
}

#define TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR) || \
    false)

static inline void _nocheck__trace_vtd_err_dmar_slpte_read_error(uint64_t iova, int level)
{
    if (trace_event_get_state(TRACE_VTD_ERR_DMAR_SLPTE_READ_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_dmar_slpte_read_error " "iova 0x%"PRIx64" level %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, level);
    }
}

static inline void trace_vtd_err_dmar_slpte_read_error(uint64_t iova, int level)
{
    if (true) {
        _nocheck__trace_vtd_err_dmar_slpte_read_error(iova, level);
    }
}

#define TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR) || \
    false)

static inline void _nocheck__trace_vtd_err_dmar_slpte_perm_error(uint64_t iova, int level, uint64_t slpte, bool is_write)
{
    if (trace_event_get_state(TRACE_VTD_ERR_DMAR_SLPTE_PERM_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_dmar_slpte_perm_error " "iova 0x%"PRIx64" level %d slpte 0x%"PRIx64" write %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, level, slpte, is_write);
    }
}

static inline void trace_vtd_err_dmar_slpte_perm_error(uint64_t iova, int level, uint64_t slpte, bool is_write)
{
    if (true) {
        _nocheck__trace_vtd_err_dmar_slpte_perm_error(iova, level, slpte, is_write);
    }
}

#define TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR) || \
    false)

static inline void _nocheck__trace_vtd_err_dmar_slpte_resv_error(uint64_t iova, int level, uint64_t slpte)
{
    if (trace_event_get_state(TRACE_VTD_ERR_DMAR_SLPTE_RESV_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_dmar_slpte_resv_error " "iova 0x%"PRIx64" level %d slpte 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , iova, level, slpte);
    }
}

static inline void trace_vtd_err_dmar_slpte_resv_error(uint64_t iova, int level, uint64_t slpte)
{
    if (true) {
        _nocheck__trace_vtd_err_dmar_slpte_resv_error(iova, level, slpte);
    }
}

#define TRACE_VTD_ERR_DMAR_TRANSLATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_DMAR_TRANSLATE) || \
    false)

static inline void _nocheck__trace_vtd_err_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova)
{
    if (trace_event_get_state(TRACE_VTD_ERR_DMAR_TRANSLATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_dmar_translate " "dev %02x:%02x.%02x iova 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, func, iova);
    }
}

static inline void trace_vtd_err_dmar_translate(uint8_t bus, uint8_t slot, uint8_t func, uint64_t iova)
{
    if (true) {
        _nocheck__trace_vtd_err_dmar_translate(bus, slot, func, iova);
    }
}

#define TRACE_VTD_WARN_INVALID_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_INVALID_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (trace_event_get_state(TRACE_VTD_WARN_INVALID_QI_TAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_warn_invalid_qi_tail " "tail 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , tail);
    }
}

static inline void trace_vtd_warn_invalid_qi_tail(uint16_t tail)
{
    if (true) {
        _nocheck__trace_vtd_warn_invalid_qi_tail(tail);
    }
}

#define TRACE_VTD_ERR_QI_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_QI_DISABLE) || \
    false)

static inline void _nocheck__trace_vtd_err_qi_disable(uint16_t head, uint16_t tail, int type)
{
    if (trace_event_get_state(TRACE_VTD_ERR_QI_DISABLE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_qi_disable " "head 0x%"PRIx16" tail 0x%"PRIx16" last_desc_type %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , head, tail, type);
    }
}

static inline void trace_vtd_err_qi_disable(uint16_t head, uint16_t tail, int type)
{
    if (true) {
        _nocheck__trace_vtd_err_qi_disable(head, tail, type);
    }
}

#define TRACE_VTD_ERR_QI_TAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_QI_TAIL) || \
    false)

static inline void _nocheck__trace_vtd_err_qi_tail(uint16_t tail, uint16_t size)
{
    if (trace_event_get_state(TRACE_VTD_ERR_QI_TAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_qi_tail " "tail 0x%"PRIx16" size 0x%"PRIx16 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , tail, size);
    }
}

static inline void trace_vtd_err_qi_tail(uint16_t tail, uint16_t size)
{
    if (true) {
        _nocheck__trace_vtd_err_qi_tail(tail, size);
    }
}

#define TRACE_VTD_ERR_IRTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_IRTE) || \
    false)

static inline void _nocheck__trace_vtd_err_irte(int index, uint64_t lo, uint64_t hi)
{
    if (trace_event_get_state(TRACE_VTD_ERR_IRTE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_irte " "index %d low 0x%"PRIx64" high 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, lo, hi);
    }
}

static inline void trace_vtd_err_irte(int index, uint64_t lo, uint64_t hi)
{
    if (true) {
        _nocheck__trace_vtd_err_irte(index, lo, hi);
    }
}

#define TRACE_VTD_ERR_IRTE_SID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_IRTE_SID) || \
    false)

static inline void _nocheck__trace_vtd_err_irte_sid(int index, uint16_t req, uint16_t target)
{
    if (trace_event_get_state(TRACE_VTD_ERR_IRTE_SID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_irte_sid " "index %d SVT_ALL sid 0x%"PRIx16" (should be: 0x%"PRIx16")" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, req, target);
    }
}

static inline void trace_vtd_err_irte_sid(int index, uint16_t req, uint16_t target)
{
    if (true) {
        _nocheck__trace_vtd_err_irte_sid(index, req, target);
    }
}

#define TRACE_VTD_ERR_IRTE_SID_BUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_IRTE_SID_BUS) || \
    false)

static inline void _nocheck__trace_vtd_err_irte_sid_bus(int index, uint8_t bus, uint8_t min, uint8_t max)
{
    if (trace_event_get_state(TRACE_VTD_ERR_IRTE_SID_BUS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_irte_sid_bus " "index %d SVT_BUS bus 0x%"PRIx8" (should be: 0x%"PRIx8"-0x%"PRIx8")" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, bus, min, max);
    }
}

static inline void trace_vtd_err_irte_sid_bus(int index, uint8_t bus, uint8_t min, uint8_t max)
{
    if (true) {
        _nocheck__trace_vtd_err_irte_sid_bus(index, bus, min, max);
    }
}

#define TRACE_VTD_ERR_IRTE_SVT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_IRTE_SVT) || \
    false)

static inline void _nocheck__trace_vtd_err_irte_svt(int index, int type)
{
    if (trace_event_get_state(TRACE_VTD_ERR_IRTE_SVT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_irte_svt " "index %d SVT type %d" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , index, type);
    }
}

static inline void trace_vtd_err_irte_svt(int index, int type)
{
    if (true) {
        _nocheck__trace_vtd_err_irte_svt(index, type);
    }
}

#define TRACE_VTD_ERR_IR_MSI_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_ERR_IR_MSI_INVALID) || \
    false)

static inline void _nocheck__trace_vtd_err_ir_msi_invalid(uint16_t sid, uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_VTD_ERR_IR_MSI_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_err_ir_msi_invalid " "sid 0x%"PRIx16" addr 0x%"PRIx64" data 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, addr, data);
    }
}

static inline void trace_vtd_err_ir_msi_invalid(uint16_t sid, uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_vtd_err_ir_msi_invalid(sid, addr, data);
    }
}

#define TRACE_VTD_WARN_IR_VECTOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_VECTOR) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_VECTOR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_warn_ir_vector " "sid 0x%"PRIx16" index %d vec %d (should be: %d)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, index, vec, target);
    }
}

static inline void trace_vtd_warn_ir_vector(uint16_t sid, int index, int vec, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_vector(sid, index, vec, target);
    }
}

#define TRACE_VTD_WARN_IR_TRIGGER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VTD_WARN_IR_TRIGGER) || \
    false)

static inline void _nocheck__trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (trace_event_get_state(TRACE_VTD_WARN_IR_TRIGGER)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:vtd_warn_ir_trigger " "sid 0x%"PRIx16" index %d trigger %d (should be: %d)" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , sid, index, trig, target);
    }
}

static inline void trace_vtd_warn_ir_trigger(uint16_t sid, int index, int trig, int target)
{
    if (true) {
        _nocheck__trace_vtd_warn_ir_trigger(sid, index, trig, target);
    }
}

#define TRACE_AMDVI_EVNTLOG_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_EVNTLOG_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_EVNTLOG_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_evntlog_fail " "error: fail to write at addr 0x%"PRIx64" +  offset 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, head);
    }
}

static inline void trace_amdvi_evntlog_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_evntlog_fail(addr, head);
    }
}

#define TRACE_AMDVI_CACHE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CACHE_UPDATE) || \
    false)

static inline void _nocheck__trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_CACHE_UPDATE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_cache_update " " update iotlb domid 0x%"PRIx16" devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , domid, bus, slot, func, gpa, txaddr);
    }
}

static inline void trace_amdvi_cache_update(uint16_t domid, uint8_t bus, uint8_t slot, uint8_t func, uint64_t gpa, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_cache_update(domid, bus, slot, func, gpa, txaddr);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_completion_wait_fail " "error: fail to write at address 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_amdvi_completion_wait_fail(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait_fail(addr);
    }
}

#define TRACE_AMDVI_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_WRITE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_mmio_write " "%s write addr 0x%"PRIx64", size %u, val 0x%"PRIx64", offset 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reg, addr, size, val, offset);
    }
}

static inline void trace_amdvi_mmio_write(const char * reg, uint64_t addr, unsigned size, uint64_t val, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_write(reg, addr, size, val, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_mmio_read " "%s read addr 0x%"PRIx64", size %u offset 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , reg, addr, size, offset);
    }
}

static inline void trace_amdvi_mmio_read(const char * reg, uint64_t addr, unsigned size, uint64_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read(reg, addr, size, offset);
    }
}

#define TRACE_AMDVI_MMIO_READ_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MMIO_READ_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (trace_event_get_state(TRACE_AMDVI_MMIO_READ_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_mmio_read_invalid " "error: addr outside region (max 0x%x): read addr 0x%" PRIx64 ", size %u" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , max, addr, size);
    }
}

static inline void trace_amdvi_mmio_read_invalid(int max, uint64_t addr, unsigned size)
{
    if (true) {
        _nocheck__trace_amdvi_mmio_read_invalid(max, addr, size);
    }
}

#define TRACE_AMDVI_COMMAND_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_ERROR) || \
    false)

static inline void _nocheck__trace_amdvi_command_error(uint64_t status)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_ERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_command_error " "error: Executing commands with command buffer disabled 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , status);
    }
}

static inline void trace_amdvi_command_error(uint64_t status)
{
    if (true) {
        _nocheck__trace_amdvi_command_error(status);
    }
}

#define TRACE_AMDVI_COMMAND_READ_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_READ_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_READ_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_command_read_fail " "error: fail to access memory at 0x%"PRIx64" + 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, head);
    }
}

static inline void trace_amdvi_command_read_fail(uint64_t addr, uint32_t head)
{
    if (true) {
        _nocheck__trace_amdvi_command_read_fail(addr, head);
    }
}

#define TRACE_AMDVI_COMMAND_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMMAND_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (trace_event_get_state(TRACE_AMDVI_COMMAND_EXEC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_command_exec " "command buffer head at 0x%"PRIx32" command buffer tail at 0x%"PRIx32" command buffer base at 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , head, tail, buf);
    }
}

static inline void trace_amdvi_command_exec(uint32_t head, uint32_t tail, uint64_t buf)
{
    if (true) {
        _nocheck__trace_amdvi_command_exec(head, tail, buf);
    }
}

#define TRACE_AMDVI_UNHANDLED_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_UNHANDLED_COMMAND) || \
    false)

static inline void _nocheck__trace_amdvi_unhandled_command(uint8_t type)
{
    if (trace_event_get_state(TRACE_AMDVI_UNHANDLED_COMMAND)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_unhandled_command " "unhandled command 0x%"PRIx8 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , type);
    }
}

static inline void trace_amdvi_unhandled_command(uint8_t type)
{
    if (true) {
        _nocheck__trace_amdvi_unhandled_command(type);
    }
}

#define TRACE_AMDVI_INTR_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INTR_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_intr_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_INTR_INVAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_intr_inval " "Interrupt table invalidated" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_intr_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_intr_inval();
    }
}

#define TRACE_AMDVI_IOTLB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_INVAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_iotlb_inval " "IOTLB pages invalidated" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_iotlb_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_inval();
    }
}

#define TRACE_AMDVI_PREFETCH_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PREFETCH_PAGES) || \
    false)

static inline void _nocheck__trace_amdvi_prefetch_pages(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PREFETCH_PAGES)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_prefetch_pages " "Pre-fetch of AMD-Vi pages requested" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_prefetch_pages(void)
{
    if (true) {
        _nocheck__trace_amdvi_prefetch_pages();
    }
}

#define TRACE_AMDVI_PAGES_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGES_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_pages_inval(uint16_t domid)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGES_INVAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_pages_inval " "AMD-Vi pages for domain 0x%"PRIx16 " invalidated" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , domid);
    }
}

static inline void trace_amdvi_pages_inval(uint16_t domid)
{
    if (true) {
        _nocheck__trace_amdvi_pages_inval(domid);
    }
}

#define TRACE_AMDVI_ALL_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_ALL_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_all_inval(void)
{
    if (trace_event_get_state(TRACE_AMDVI_ALL_INVAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_all_inval " "Invalidation of all AMD-Vi cache requested " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_all_inval(void)
{
    if (true) {
        _nocheck__trace_amdvi_all_inval();
    }
}

#define TRACE_AMDVI_PPR_EXEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PPR_EXEC) || \
    false)

static inline void _nocheck__trace_amdvi_ppr_exec(void)
{
    if (trace_event_get_state(TRACE_AMDVI_PPR_EXEC)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_ppr_exec " "Execution of PPR queue requested " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_ppr_exec(void)
{
    if (true) {
        _nocheck__trace_amdvi_ppr_exec();
    }
}

#define TRACE_AMDVI_DEVTAB_INVAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DEVTAB_INVAL) || \
    false)

static inline void _nocheck__trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (trace_event_get_state(TRACE_AMDVI_DEVTAB_INVAL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_devtab_inval " "device table entry for devid: %02x:%02x.%x invalidated" "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, func);
    }
}

static inline void trace_amdvi_devtab_inval(uint8_t bus, uint8_t slot, uint8_t func)
{
    if (true) {
        _nocheck__trace_amdvi_devtab_inval(bus, slot, func);
    }
}

#define TRACE_AMDVI_COMPLETION_WAIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_COMPLETION_WAIT) || \
    false)

static inline void _nocheck__trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (trace_event_get_state(TRACE_AMDVI_COMPLETION_WAIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_completion_wait " "completion wait requested with store address 0x%"PRIx64" and store data 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, data);
    }
}

static inline void trace_amdvi_completion_wait(uint64_t addr, uint64_t data)
{
    if (true) {
        _nocheck__trace_amdvi_completion_wait(addr, data);
    }
}

#define TRACE_AMDVI_CONTROL_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_CONTROL_STATUS) || \
    false)

static inline void _nocheck__trace_amdvi_control_status(uint64_t val)
{
    if (trace_event_get_state(TRACE_AMDVI_CONTROL_STATUS)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_control_status " "MMIO_STATUS state 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , val);
    }
}

static inline void trace_amdvi_control_status(uint64_t val)
{
    if (true) {
        _nocheck__trace_amdvi_control_status(val);
    }
}

#define TRACE_AMDVI_IOTLB_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_RESET) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_reset(void)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_RESET)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_iotlb_reset " "IOTLB exceed size limit - reset " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      );
    }
}

static inline void trace_amdvi_iotlb_reset(void)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_reset();
    }
}

#define TRACE_AMDVI_DTE_GET_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_DTE_GET_FAIL) || \
    false)

static inline void _nocheck__trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (trace_event_get_state(TRACE_AMDVI_DTE_GET_FAIL)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_dte_get_fail " "error: failed to access Device Entry devtab 0x%"PRIx64" offset 0x%"PRIx32 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr, offset);
    }
}

static inline void trace_amdvi_dte_get_fail(uint64_t addr, uint32_t offset)
{
    if (true) {
        _nocheck__trace_amdvi_dte_get_fail(addr, offset);
    }
}

#define TRACE_AMDVI_INVALID_DTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_INVALID_DTE) || \
    false)

static inline void _nocheck__trace_amdvi_invalid_dte(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_INVALID_DTE)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_invalid_dte " "PTE entry at 0x%"PRIx64" is invalid " "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_amdvi_invalid_dte(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_invalid_dte(addr);
    }
}

#define TRACE_AMDVI_GET_PTE_HWERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_GET_PTE_HWERROR) || \
    false)

static inline void _nocheck__trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_GET_PTE_HWERROR)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_get_pte_hwerror " "hardware error eccessing PTE at addr 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_amdvi_get_pte_hwerror(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_get_pte_hwerror(addr);
    }
}

#define TRACE_AMDVI_MODE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_MODE_INVALID) || \
    false)

static inline void _nocheck__trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_MODE_INVALID)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_mode_invalid " "error: translation level 0x%"PRIx8" translating addr 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , level, addr);
    }
}

static inline void trace_amdvi_mode_invalid(uint8_t level, uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_mode_invalid(level, addr);
    }
}

#define TRACE_AMDVI_PAGE_FAULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_PAGE_FAULT) || \
    false)

static inline void _nocheck__trace_amdvi_page_fault(uint64_t addr)
{
    if (trace_event_get_state(TRACE_AMDVI_PAGE_FAULT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_page_fault " "error: page fault accessing guest physical address 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , addr);
    }
}

static inline void trace_amdvi_page_fault(uint64_t addr)
{
    if (true) {
        _nocheck__trace_amdvi_page_fault(addr);
    }
}

#define TRACE_AMDVI_IOTLB_HIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_IOTLB_HIT) || \
    false)

static inline void _nocheck__trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_IOTLB_HIT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_iotlb_hit " "hit iotlb devid %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, func, addr, txaddr);
    }
}

static inline void trace_amdvi_iotlb_hit(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_iotlb_hit(bus, slot, func, addr, txaddr);
    }
}

#define TRACE_AMDVI_TRANSLATION_RESULT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_AMDVI_TRANSLATION_RESULT) || \
    false)

static inline void _nocheck__trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (trace_event_get_state(TRACE_AMDVI_TRANSLATION_RESULT)) {
        struct timeval _now;
        gettimeofday(&_now, NULL);
        qemu_log_mask(LOG_TRACE,
                      "%d@%zd.%06zd:amdvi_translation_result " "devid: %02x:%02x.%x gpa 0x%"PRIx64" hpa 0x%"PRIx64 "\n",
                      getpid(),
                      (size_t)_now.tv_sec, (size_t)_now.tv_usec
                      , bus, slot, func, addr, txaddr);
    }
}

static inline void trace_amdvi_translation_result(uint8_t bus, uint8_t slot, uint8_t func, uint64_t addr, uint64_t txaddr)
{
    if (true) {
        _nocheck__trace_amdvi_translation_result(bus, slot, func, addr, txaddr);
    }
}
#endif /* TRACE_HW_I386_GENERATED_TRACERS_H */
